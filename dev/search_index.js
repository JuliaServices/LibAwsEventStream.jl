var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = LibAwsEventStream","category":"page"},{"location":"#LibAwsEventStream","page":"Home","title":"LibAwsEventStream","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for LibAwsEventStream.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [LibAwsEventStream]","category":"page"},{"location":"#LibAwsEventStream.AWS_C_EVENT_STREAM_PACKAGE_ID","page":"Home","title":"LibAwsEventStream.AWS_C_EVENT_STREAM_PACKAGE_ID","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsEventStream.AWS_EVENT_STREAM_HEADER_NAME_LEN_MAX","page":"Home","title":"LibAwsEventStream.AWS_EVENT_STREAM_HEADER_NAME_LEN_MAX","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsEventStream.AWS_EVENT_STREAM_HEADER_STATIC_VALUE_LEN_MAX","page":"Home","title":"LibAwsEventStream.AWS_EVENT_STREAM_HEADER_STATIC_VALUE_LEN_MAX","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsEventStream.AWS_EVENT_STREAM_MAX_HEADERS_SIZE","page":"Home","title":"LibAwsEventStream.AWS_EVENT_STREAM_MAX_HEADERS_SIZE","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsEventStream.AWS_EVENT_STREAM_MAX_MESSAGE_SIZE","page":"Home","title":"LibAwsEventStream.AWS_EVENT_STREAM_MAX_MESSAGE_SIZE","text":"Documentation not found.\n\n\n\n\n\n","category":"constant"},{"location":"#LibAwsEventStream.__JL_Ctag_201","page":"Home","title":"LibAwsEventStream.__JL_Ctag_201","text":"__JL_Ctag_201\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_channel_handler","page":"Home","title":"LibAwsEventStream.aws_event_stream_channel_handler","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_channel_handler_on_message_received_fn","page":"Home","title":"LibAwsEventStream.aws_event_stream_channel_handler_on_message_received_fn","text":"Invoked when an aws_event_stream_message is encountered. If the message parsed successfully, message will be non-null and error_code will be AWS_ERROR_SUCCESS. Otherwise message will be null and error_code will represent the error that was encountered. Note that any case that error_code was not AWS_OP_SUCCESS, the channel also shuts down.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_channel_handler_on_message_written_fn","page":"Home","title":"LibAwsEventStream.aws_event_stream_channel_handler_on_message_written_fn","text":"Invoked when an aws_event_stream_message is flushed to the IO interface. When error_code is AWS_ERROR_SUCCESS the write happened successfuly. Regardless, message is held from the aws_event_stream_channel_handler_write_message() call and should likely be freed in this callback. If error_code is non-zero, the channel will be shutdown immediately after this callback returns.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_channel_handler_options","page":"Home","title":"LibAwsEventStream.aws_event_stream_channel_handler_options","text":"aws_event_stream_channel_handler_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_errors","page":"Home","title":"LibAwsEventStream.aws_event_stream_errors","text":"aws_event_stream_errors\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_header_received_fn","page":"Home","title":"LibAwsEventStream.aws_event_stream_header_received_fn","text":"Called by aws_aws_event_stream_streaming_decoder when a header is encountered. 'header' is not yours. Copy the data you want from it if your scope extends beyond your callback.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_header_value_pair","page":"Home","title":"LibAwsEventStream.aws_event_stream_header_value_pair","text":"aws_event_stream_header_value_pair\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_header_value_type","page":"Home","title":"LibAwsEventStream.aws_event_stream_header_value_type","text":"aws_event_stream_header_value_type\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_log_subject","page":"Home","title":"LibAwsEventStream.aws_event_stream_log_subject","text":"aws_event_stream_log_subject\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_message","page":"Home","title":"LibAwsEventStream.aws_event_stream_message","text":"aws_event_stream_message\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_message_prelude","page":"Home","title":"LibAwsEventStream.aws_event_stream_message_prelude","text":"aws_event_stream_message_prelude\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_on_complete_fn","page":"Home","title":"LibAwsEventStream.aws_event_stream_on_complete_fn","text":"Called by aws_aws_event_stream_streaming_decoder when a message decoding is complete and crc is verified.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_on_error_fn","page":"Home","title":"LibAwsEventStream.aws_event_stream_on_error_fn","text":"Called by aws_aws_event_stream_streaming_decoder when an error is encountered. The decoder is not in a good state for usage after this callback.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_prelude_received_fn","page":"Home","title":"LibAwsEventStream.aws_event_stream_prelude_received_fn","text":"Called by aws_aws_event_stream_streaming_decoder when a new message has arrived. The prelude will contain metadata about the message. At this point no headers or payload have been received. prelude is copyable.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_process_on_payload_segment_fn","page":"Home","title":"LibAwsEventStream.aws_event_stream_process_on_payload_segment_fn","text":"Called by aws_aws_event_stream_streaming_decoder when payload data has been received. 'data' doesn't belong to you, so copy the data if it is needed beyond the scope of your callback. final_segment == 1 indicates the current data is the last payload buffer for that message.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_process_state_fn","page":"Home","title":"LibAwsEventStream.aws_event_stream_process_state_fn","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_client_connection","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_client_connection","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_client_connection_options","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_client_connection_options","text":"aws_event_stream_rpc_client_connection_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_client_connection_protocol_message_fn","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_client_connection_protocol_message_fn","text":"Invoked when a non-stream level message is received on a connection.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_client_continuation_token","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_client_continuation_token","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_client_message_flush_fn","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_client_message_flush_fn","text":"Invoked whenever a message has been flushed to the channel.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_client_on_connection_setup_fn","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_client_on_connection_setup_fn","text":"Invoked when a connection attempt completes.\n\nIf the attempt was unsuccessful, the error_code will be non-zero and the connection pointer will be NULL, and aws_event_stream_rpc_client_on_connection_shutdown_fn will not be invoked.\n\nIf the attempt was successful, error_code will be 0 and the connection pointer will be valid. You must call aws_event_stream_rpc_client_connection_acquire() to prevent the pointer's memory from being destroyed before you are ready. When you are completely done with the connection pointer you must call aws_event_stream_rpc_client_connection_release() or its memory will leak. aws_event_stream_rpc_client_on_connection_shutdown_fn will be invoked when the network connection has closed. If you are done with the connection, but it is still open, you must call aws_aws_event_stream_rpc_client_close() or network connection will remain open, even if you call release().\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_client_on_connection_shutdown_fn","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_client_on_connection_shutdown_fn","text":"Invoked when a successfully created connection is shutdown. error_code will indicate the reason for the shutdown.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_client_stream_continuation_closed_fn","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_client_stream_continuation_closed_fn","text":"Invoked when a continuation has either been closed with the TERMINATE_STREAM flag, or when the connection shuts down and deletes the continuation.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_client_stream_continuation_fn","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_client_stream_continuation_fn","text":"Invoked when a connection receives a message on an existing stream. message_args contains the message data.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_client_stream_continuation_options","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_client_stream_continuation_options","text":"aws_event_stream_rpc_client_stream_continuation_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_connection_options","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_connection_options","text":"aws_event_stream_rpc_connection_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_message_args","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_message_args","text":"aws_event_stream_rpc_message_args\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_message_flag","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_message_flag","text":"aws_event_stream_rpc_message_flag\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_message_type","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_message_type","text":"aws_event_stream_rpc_message_type\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_connection","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_connection","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_connection_protocol_message_fn","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_connection_protocol_message_fn","text":"Invoked when a non-stream level message is received on a connection.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_continuation_token","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_continuation_token","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_listener","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_listener","text":"Documentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_listener_options","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_listener_options","text":"aws_event_stream_rpc_server_listener_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_message_flush_fn","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_message_flush_fn","text":"Invoked whenever a message has been flushed to the channel.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_on_connection_shutdown_fn","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_on_connection_shutdown_fn","text":"Invoked when a successfully created connection is shutdown. error_code will indicate the reason for the shutdown.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_on_incoming_stream_fn","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_on_incoming_stream_fn","text":"Invoked when a new stream has been received on the connection. If you return AWS_OP_SUCCESS (0), You must fill in the fields for continuation options or the program will assert and exit.\n\nA failure path MUST leave the ref count of the continuation alone.\n\nA success path should probably take a ref which will leave the continuation (assuming no other interference) at two AFTER creation is complete: 1 for the connection's continuation table, and one for the callback recipient which is presumably tracking it as well.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_on_listener_destroy_fn","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_on_listener_destroy_fn","text":"(Optional). Invoked when the listener has been successfully shutdown (after the last ref count release).\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_on_new_connection_fn","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_on_new_connection_fn","text":"Invoked when a new connection is received on a server listener. If you return AWS_OP_SUCCESS, You must fill in the fields for connection_options or the program will assert and exit.\n\nIf error_code is non-zero, an error occurred upon setting up the channel and connection will be NULL. Otherwise, connection is non-null. If you intend to seat a pointer to connection, you MUST call aws_event_stream_rpc_server_connection_acquire() and when you're finished with the connection you MUST call aws_event_stream_server_connection_release().\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_stream_continuation_closed_fn","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_stream_continuation_closed_fn","text":"Invoked when a continuation has either been closed with the TERMINATE_STREAM flag, or when the connection shutsdown and deletes the continuation.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_stream_continuation_fn","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_stream_continuation_fn","text":"Invoked when a connection receives a message on an existing stream. message_args contains the message data.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_stream_continuation_options","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_stream_continuation_options","text":"aws_event_stream_rpc_server_stream_continuation_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_streaming_decoder","page":"Home","title":"LibAwsEventStream.aws_event_stream_streaming_decoder","text":"aws_event_stream_streaming_decoder\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_streaming_decoder_options","page":"Home","title":"LibAwsEventStream.aws_event_stream_streaming_decoder_options","text":"aws_event_stream_streaming_decoder_options\n\nDocumentation not found.\n\n\n\n\n\n","category":"type"},{"location":"#LibAwsEventStream.aws_event_stream_add_bool_header-NTuple{4, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_add_bool_header","text":"aws_event_stream_add_bool_header(headers, name, name_len, value)\n\nAdds a bool header to the list of headers.\n\nPrototype\n\nint aws_event_stream_add_bool_header( struct aws_array_list *headers, const char *name, uint8_t name_len, int8_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_add_bool_header_by_cursor-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_add_bool_header_by_cursor","text":"aws_event_stream_add_bool_header_by_cursor(headers, name, value)\n\nAdds a boolean-valued header to a header list\n\nArguments\n\nheaders: header list to add to\nname: name of the header to add\nvalue: value of the header to add\n\nReturns\n\nAWS_OP_SUCCESS on success, AWS_OP_ERR on failure\n\nPrototype\n\nint aws_event_stream_add_bool_header_by_cursor( struct aws_array_list *headers, struct aws_byte_cursor name, bool value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_add_byte_buf_header_by_cursor-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_add_byte_buf_header_by_cursor","text":"aws_event_stream_add_byte_buf_header_by_cursor(headers, name, value)\n\nAdds a byte_buf-valued header to a header list\n\nArguments\n\nheaders: header list to add to\nname: name of the header to add\nvalue: value of the header to add\n\nReturns\n\nAWS_OP_SUCCESS on success, AWS_OP_ERR on failure\n\nPrototype\n\nint aws_event_stream_add_byte_buf_header_by_cursor( struct aws_array_list *headers, struct aws_byte_cursor name, struct aws_byte_cursor value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_add_byte_header-NTuple{4, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_add_byte_header","text":"aws_event_stream_add_byte_header(headers, name, name_len, value)\n\nAdds a byte header to the list of headers.\n\nPrototype\n\nint aws_event_stream_add_byte_header( struct aws_array_list *headers, const char *name, uint8_t name_len, int8_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_add_byte_header_by_cursor-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_add_byte_header_by_cursor","text":"aws_event_stream_add_byte_header_by_cursor(headers, name, value)\n\nAdds a byte-valued header to a header list\n\nArguments\n\nheaders: header list to add to\nname: name of the header to add\nvalue: value of the header to add\n\nReturns\n\nAWS_OP_SUCCESS on success, AWS_OP_ERR on failure\n\nPrototype\n\nint aws_event_stream_add_byte_header_by_cursor( struct aws_array_list *headers, struct aws_byte_cursor name, int8_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_add_bytebuf_header-NTuple{6, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_add_bytebuf_header","text":"aws_event_stream_add_bytebuf_header(headers, name, name_len, value, value_len, copy)\n\nAdds a byte-buffer header to the list of headers. If copy is set to true, this will result in an allocation for the header value. Otherwise, the value will be set to the memory address of 'value'.\n\nPrototype\n\nint aws_event_stream_add_bytebuf_header( struct aws_array_list *headers, const char *name, uint8_t name_len, uint8_t *value, uint16_t value_len, int8_t copy);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_add_header-Tuple{Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_add_header","text":"aws_event_stream_add_header(headers, header)\n\nAdds a generic header to the list of headers. Makes a copy of the underlaying data.\n\nPrototype\n\nint aws_event_stream_add_header( struct aws_array_list *headers, const struct aws_event_stream_header_value_pair *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_add_int16_header-NTuple{4, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_add_int16_header","text":"aws_event_stream_add_int16_header(headers, name, name_len, value)\n\nadds a 16 bit integer to the list of headers.\n\nPrototype\n\nint aws_event_stream_add_int16_header( struct aws_array_list *headers, const char *name, uint8_t name_len, int16_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_add_int16_header_by_cursor-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_add_int16_header_by_cursor","text":"aws_event_stream_add_int16_header_by_cursor(headers, name, value)\n\nAdds a int16-valued header to a header list\n\nArguments\n\nheaders: header list to add to\nname: name of the header to add\nvalue: value of the header to add\n\nReturns\n\nAWS_OP_SUCCESS on success, AWS_OP_ERR on failure\n\nPrototype\n\nint aws_event_stream_add_int16_header_by_cursor( struct aws_array_list *headers, struct aws_byte_cursor name, int16_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_add_int32_header-NTuple{4, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_add_int32_header","text":"aws_event_stream_add_int32_header(headers, name, name_len, value)\n\nadds a 32 bit integer to the list of headers.\n\nPrototype\n\nint aws_event_stream_add_int32_header( struct aws_array_list *headers, const char *name, uint8_t name_len, int32_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_add_int32_header_by_cursor-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_add_int32_header_by_cursor","text":"aws_event_stream_add_int32_header_by_cursor(headers, name, value)\n\nAdds a int32-valued header to a header list\n\nArguments\n\nheaders: header list to add to\nname: name of the header to add\nvalue: value of the header to add\n\nReturns\n\nAWS_OP_SUCCESS on success, AWS_OP_ERR on failure\n\nPrototype\n\nint aws_event_stream_add_int32_header_by_cursor( struct aws_array_list *headers, struct aws_byte_cursor name, int32_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_add_int64_header-NTuple{4, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_add_int64_header","text":"aws_event_stream_add_int64_header(headers, name, name_len, value)\n\nadds a 64 bit integer to the list of headers.\n\nPrototype\n\nint aws_event_stream_add_int64_header( struct aws_array_list *headers, const char *name, uint8_t name_len, int64_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_add_int64_header_by_cursor-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_add_int64_header_by_cursor","text":"aws_event_stream_add_int64_header_by_cursor(headers, name, value)\n\nAdds a int64-valued header to a header list\n\nArguments\n\nheaders: header list to add to\nname: name of the header to add\nvalue: value of the header to add\n\nReturns\n\nAWS_OP_SUCCESS on success, AWS_OP_ERR on failure\n\nPrototype\n\nint aws_event_stream_add_int64_header_by_cursor( struct aws_array_list *headers, struct aws_byte_cursor name, int64_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_add_string_header-NTuple{6, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_add_string_header","text":"aws_event_stream_add_string_header(headers, name, name_len, value, value_len, copy)\n\nAdds a string header to the list of headers. If copy is set to true, this will result in an allocation for the header value. Otherwise, the value will be set to the memory address of 'value'.\n\nPrototype\n\nint aws_event_stream_add_string_header( struct aws_array_list *headers, const char *name, uint8_t name_len, const char *value, uint16_t value_len, int8_t copy);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_add_string_header_by_cursor-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_add_string_header_by_cursor","text":"aws_event_stream_add_string_header_by_cursor(headers, name, value)\n\nAdds a string-valued header to a header list\n\nArguments\n\nheaders: header list to add to\nname: name of the header to add\nvalue: value of the header to add\n\nReturns\n\nAWS_OP_SUCCESS on success, AWS_OP_ERR on failure\n\nPrototype\n\nint aws_event_stream_add_string_header_by_cursor( struct aws_array_list *headers, struct aws_byte_cursor name, struct aws_byte_cursor value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_add_timestamp_header-NTuple{4, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_add_timestamp_header","text":"aws_event_stream_add_timestamp_header(headers, name, name_len, value)\n\nadds a 64 bit integer representing milliseconds since unix epoch to the list of headers.\n\nPrototype\n\nint aws_event_stream_add_timestamp_header( struct aws_array_list *headers, const char *name, uint8_t name_len, int64_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_add_timestamp_header_by_cursor-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_add_timestamp_header_by_cursor","text":"aws_event_stream_add_timestamp_header_by_cursor(headers, name, value)\n\nAdds a timestamp-valued header to a header list\n\nArguments\n\nheaders: header list to add to\nname: name of the header to add\nvalue: value of the header to add\n\nReturns\n\nAWS_OP_SUCCESS on success, AWS_OP_ERR on failure\n\nPrototype\n\nint aws_event_stream_add_timestamp_header_by_cursor( struct aws_array_list *headers, struct aws_byte_cursor name, int64_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_add_uuid_header-NTuple{4, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_add_uuid_header","text":"aws_event_stream_add_uuid_header(headers, name, name_len, value)\n\nadds a uuid buffer to the list of headers. Value must always be 16 bytes long.\n\nPrototype\n\nint aws_event_stream_add_uuid_header( struct aws_array_list *headers, const char *name, uint8_t name_len, const uint8_t *value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_add_uuid_header_by_cursor-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_add_uuid_header_by_cursor","text":"aws_event_stream_add_uuid_header_by_cursor(headers, name, value)\n\nAdds a uuid-valued header to a header list\n\nArguments\n\nheaders: header list to add to\nname: name of the header to add\nvalue: value of the header to add\n\nReturns\n\nAWS_OP_SUCCESS on success, AWS_OP_ERR on failure\n\nPrototype\n\nint aws_event_stream_add_uuid_header_by_cursor( struct aws_array_list *headers, struct aws_byte_cursor name, struct aws_byte_cursor value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_channel_handler_get_user_data-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_channel_handler_get_user_data","text":"aws_event_stream_channel_handler_get_user_data(handler)\n\nDocumentation not found.\n\nPrototype\n\nvoid *aws_event_stream_channel_handler_get_user_data(struct aws_channel_handler *handler);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_channel_handler_increment_read_window-Tuple{Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_channel_handler_increment_read_window","text":"aws_event_stream_channel_handler_increment_read_window(handler, window_update_size)\n\nUpdates the read window for the channel if automatic_window_managemanet was set to false.\n\nPrototype\n\nvoid aws_event_stream_channel_handler_increment_read_window( struct aws_channel_handler *handler, size_t window_update_size);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_channel_handler_new-Tuple{Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_channel_handler_new","text":"aws_event_stream_channel_handler_new(allocator, handler_options)\n\nAllocates and initializes a new channel handler for processing aws_event_stream_message() events. Handler options must not be null.\n\nPrototype\n\nstruct aws_channel_handler *aws_event_stream_channel_handler_new( struct aws_allocator *allocator, const struct aws_event_stream_channel_handler_options *handler_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_channel_handler_write_message-NTuple{4, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_channel_handler_write_message","text":"aws_event_stream_channel_handler_write_message(handler, message, on_message_written, user_data)\n\nWrites an aws_event_stream_message() to the channel. Once the channel flushes or an error occurs, on_message_written will be invoked. message should stay valid until the callback is invoked. If an error an occurs, the channel will automatically be shutdown.\n\nPrototype\n\nint aws_event_stream_channel_handler_write_message( struct aws_channel_handler *handler, struct aws_event_stream_message *message, aws_event_stream_channel_handler_on_message_written_fn *on_message_written, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_compute_headers_required_buffer_len-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_compute_headers_required_buffer_len","text":"aws_event_stream_compute_headers_required_buffer_len(headers)\n\nDocumentation not found.\n\nPrototype\n\nuint32_t aws_event_stream_compute_headers_required_buffer_len(const struct aws_array_list *headers);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_create_int32_header-Tuple{Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_create_int32_header","text":"aws_event_stream_create_int32_header(name, value)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_event_stream_header_value_pair aws_event_stream_create_int32_header( struct aws_byte_cursor name, int32_t value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_create_string_header-Tuple{Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_create_string_header","text":"aws_event_stream_create_string_header(name, value)\n\nDocumentation not found.\n\nPrototype\n\nstruct aws_event_stream_header_value_pair aws_event_stream_create_string_header( struct aws_byte_cursor name, struct aws_byte_cursor value);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_header_name-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_header_name","text":"aws_event_stream_header_name(header)\n\nReturns the header name. Note: this value is not null terminated\n\nPrototype\n\nstruct aws_byte_buf aws_event_stream_header_name( struct aws_event_stream_header_value_pair *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_header_value_as_bool-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_header_value_as_bool","text":"aws_event_stream_header_value_as_bool(header)\n\nReturns the header value as a boolean value.\n\nPrototype\n\nint8_t aws_event_stream_header_value_as_bool(struct aws_event_stream_header_value_pair *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_header_value_as_byte-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_header_value_as_byte","text":"aws_event_stream_header_value_as_byte(header)\n\nReturns the header value as a byte\n\nPrototype\n\nint8_t aws_event_stream_header_value_as_byte(struct aws_event_stream_header_value_pair *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_header_value_as_bytebuf-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_header_value_as_bytebuf","text":"aws_event_stream_header_value_as_bytebuf(header)\n\nReturns the header value as a pointer to a byte buffer, call aws_event_stream_header_value_length to determine the length of the buffer.\n\nPrototype\n\nstruct aws_byte_buf aws_event_stream_header_value_as_bytebuf( struct aws_event_stream_header_value_pair *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_header_value_as_int16-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_header_value_as_int16","text":"aws_event_stream_header_value_as_int16(header)\n\nReturns the header value as a 16 bit integer.\n\nPrototype\n\nint16_t aws_event_stream_header_value_as_int16(struct aws_event_stream_header_value_pair *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_header_value_as_int32-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_header_value_as_int32","text":"aws_event_stream_header_value_as_int32(header)\n\nReturns the header value as a 32 bit integer.\n\nPrototype\n\nint32_t aws_event_stream_header_value_as_int32(struct aws_event_stream_header_value_pair *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_header_value_as_int64-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_header_value_as_int64","text":"aws_event_stream_header_value_as_int64(header)\n\nReturns the header value as a 64 bit integer.\n\nPrototype\n\nint64_t aws_event_stream_header_value_as_int64(struct aws_event_stream_header_value_pair *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_header_value_as_string-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_header_value_as_string","text":"aws_event_stream_header_value_as_string(header)\n\nReturns the header value as a string. Note: this value is not null terminated.\n\nPrototype\n\nstruct aws_byte_buf aws_event_stream_header_value_as_string( struct aws_event_stream_header_value_pair *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_header_value_as_timestamp-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_header_value_as_timestamp","text":"aws_event_stream_header_value_as_timestamp(header)\n\nReturns the header value as a 64 bit integer representing milliseconds since unix epoch.\n\nPrototype\n\nint64_t aws_event_stream_header_value_as_timestamp(struct aws_event_stream_header_value_pair *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_header_value_as_uuid-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_header_value_as_uuid","text":"aws_event_stream_header_value_as_uuid(header)\n\nReturns the header value a byte buffer which is 16 bytes long. Represents a UUID.\n\nPrototype\n\nstruct aws_byte_buf aws_event_stream_header_value_as_uuid( struct aws_event_stream_header_value_pair *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_header_value_length-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_header_value_length","text":"aws_event_stream_header_value_length(header)\n\nReturns the length of the header value buffer. This is mostly intended for string and byte buffer types.\n\nPrototype\n\nuint16_t aws_event_stream_header_value_length(struct aws_event_stream_header_value_pair *header);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_headers_list_cleanup-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_headers_list_cleanup","text":"aws_event_stream_headers_list_cleanup(headers)\n\nCleans up the headers list. Also deallocates any headers that were the result of a copy flag for strings or buffer.\n\nPrototype\n\nvoid aws_event_stream_headers_list_cleanup(struct aws_array_list *headers);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_headers_list_init-Tuple{Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_headers_list_init","text":"aws_event_stream_headers_list_init(headers, allocator)\n\ninitializes a headers list for you. It will default to a capacity of 4 in dynamic mode.\n\nPrototype\n\nint aws_event_stream_headers_list_init( struct aws_array_list *headers, struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_library_clean_up-Tuple{}","page":"Home","title":"LibAwsEventStream.aws_event_stream_library_clean_up","text":"aws_event_stream_library_clean_up()\n\nClean up internal datastructures used by aws-c-event-stream. Must not be called until application is done using functionality in aws-c-event-stream.\n\nPrototype\n\nvoid aws_event_stream_library_clean_up(void);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_library_init-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_library_init","text":"aws_event_stream_library_init(allocator)\n\nInitializes internal datastructures used by aws-c-event-stream. Must be called before using any functionality in aws-c-event-stream.\n\nPrototype\n\nvoid aws_event_stream_library_init(struct aws_allocator *allocator);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_message_buffer-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_message_buffer","text":"aws_event_stream_message_buffer(message)\n\nReturns the message as a buffer ready for transport.\n\nPrototype\n\nconst uint8_t *aws_event_stream_message_buffer(const struct aws_event_stream_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_message_clean_up-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_message_clean_up","text":"aws_event_stream_message_clean_up(message)\n\nCleans up any internally allocated memory. Always call this for API compatibility reasons, even if you only used the aws_aws_event_stream_message_from_buffer function.\n\nPrototype\n\nvoid aws_event_stream_message_clean_up(struct aws_event_stream_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_message_from_buffer-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_message_from_buffer","text":"aws_event_stream_message_from_buffer(message, alloc, buffer)\n\nZero allocation, Zero copy. The message will simply wrap the buffer. The message functions are only useful as long as buffer is referencable memory.\n\nPrototype\n\nint aws_event_stream_message_from_buffer( struct aws_event_stream_message *message, struct aws_allocator *alloc, struct aws_byte_buf *buffer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_message_from_buffer_copy-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_message_from_buffer_copy","text":"aws_event_stream_message_from_buffer_copy(message, alloc, buffer)\n\nAllocates memory and copies buffer. Otherwise the same as aws_aws_event_stream_message_from_buffer. This is slower, but possibly safer.\n\nPrototype\n\nint aws_event_stream_message_from_buffer_copy( struct aws_event_stream_message *message, struct aws_allocator *alloc, const struct aws_byte_buf *buffer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_message_headers-Tuple{Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_message_headers","text":"aws_event_stream_message_headers(message, headers)\n\nAdds the headers for the message to list. The memory in each header is owned as part of the message, do not free it or pass its address around.\n\nPrototype\n\nint aws_event_stream_message_headers( const struct aws_event_stream_message *message, struct aws_array_list *headers);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_message_headers_len-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_message_headers_len","text":"aws_event_stream_message_headers_len(message)\n\nReturns the length of the headers portion of the message.\n\nPrototype\n\nuint32_t aws_event_stream_message_headers_len(const struct aws_event_stream_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_message_init-NTuple{4, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_message_init","text":"aws_event_stream_message_init(message, alloc, headers, payload)\n\nInitializes with a list of headers, the payload, and a payload length. CRCs will be computed for you. If headers or payload is NULL, then the fields will be appropriately set to indicate no headers and/or no payload. Both payload and headers will result in an allocation.\n\nPrototype\n\nint aws_event_stream_message_init( struct aws_event_stream_message *message, struct aws_allocator *alloc, const struct aws_array_list *headers, const struct aws_byte_buf *payload);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_message_message_crc-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_message_message_crc","text":"aws_event_stream_message_message_crc(message)\n\nReturns the checksum of the entire message (crc32)\n\nPrototype\n\nuint32_t aws_event_stream_message_message_crc(const struct aws_event_stream_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_message_payload-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_message_payload","text":"aws_event_stream_message_payload(message)\n\nReturns a pointer to the beginning of the message payload.\n\nPrototype\n\nconst uint8_t *aws_event_stream_message_payload(const struct aws_event_stream_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_message_payload_len-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_message_payload_len","text":"aws_event_stream_message_payload_len(message)\n\nReturns the length of the message payload.\n\nPrototype\n\nuint32_t aws_event_stream_message_payload_len(const struct aws_event_stream_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_message_prelude_crc-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_message_prelude_crc","text":"aws_event_stream_message_prelude_crc(message)\n\nReturns the prelude crc (crc32)\n\nPrototype\n\nuint32_t aws_event_stream_message_prelude_crc(const struct aws_event_stream_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_message_to_debug_str-Tuple{Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_message_to_debug_str","text":"aws_event_stream_message_to_debug_str(fd, message)\n\nWrites the message to fd in json format. All strings and binary fields are base64 encoded.\n\nPrototype\n\nint aws_event_stream_message_to_debug_str( FILE *fd, const struct aws_event_stream_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_message_total_length-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_message_total_length","text":"aws_event_stream_message_total_length(message)\n\nReturns the total length of the message (including the length field).\n\nPrototype\n\nuint32_t aws_event_stream_message_total_length(const struct aws_event_stream_message *message);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_read_headers_from_buffer-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_read_headers_from_buffer","text":"aws_event_stream_read_headers_from_buffer(headers, buffer, headers_len)\n\nGet the headers from the buffer, store them in the headers list. the user's responsibility to cleanup the list when they are finished with it. no buffer copies happen here, the lifetime of the buffer, must outlive the usage of the headers. returns error codes defined in the public interface.\n\nPrototype\n\nint aws_event_stream_read_headers_from_buffer( struct aws_array_list *headers, const uint8_t *buffer, size_t headers_len);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_client_connection_acquire-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_client_connection_acquire","text":"aws_event_stream_rpc_client_connection_acquire(connection)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_event_stream_rpc_client_connection_acquire( const struct aws_event_stream_rpc_client_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_client_connection_close-Tuple{Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_client_connection_close","text":"aws_event_stream_rpc_client_connection_close(connection, shutdown_error_code)\n\nCloses the connection if it is open and aws_event_stream_rpc_client_connection_options::on_connection_shutdown will be invoked upon shutdown. shutdown_error_code will indicate the reason for shutdown. For a graceful shutdown pass 0 or AWS_ERROR_SUCCESS.\n\nPrototype\n\nvoid aws_event_stream_rpc_client_connection_close( struct aws_event_stream_rpc_client_connection *connection, int shutdown_error_code);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_client_connection_connect-Tuple{Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_client_connection_connect","text":"aws_event_stream_rpc_client_connection_connect(allocator, conn_options)\n\nInitiate a new connection. If this function returns AWS_OP_SUCESSS, the aws_event_stream_rpc_client_connection_options::on_connection_setup is guaranteed to be called exactly once. If that callback successfully creates a connection, aws_event_stream_rpc_client_connection_options::on_connection_shutdown will be invoked upon connection closure. However if the connection was never successfully setup, aws_event_stream_rpc_client_connection_options::on_connection_shutdown will not be invoked later.\n\nPrototype\n\nint aws_event_stream_rpc_client_connection_connect( struct aws_allocator *allocator, const struct aws_event_stream_rpc_client_connection_options *conn_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_client_connection_is_open-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_client_connection_is_open","text":"aws_event_stream_rpc_client_connection_is_open(connection)\n\nReturns true if the connection is open, false otherwise.\n\nPrototype\n\nbool aws_event_stream_rpc_client_connection_is_open( const struct aws_event_stream_rpc_client_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_client_connection_new_stream-Tuple{Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_client_connection_new_stream","text":"aws_event_stream_rpc_client_connection_new_stream(connection, continuation_options)\n\nCreate a new stream. continuation_option's callbacks will not be invoked, and nothing will be sent across the wire until aws_event_stream_rpc_client_continuation_activate() is invoked.\n\nreturns an instance of a aws_event_stream_rpc_client_continuation_token on success with a reference count of 1. You must call aws_event_stream_rpc_client_continuation_release() when you're finished with it. Returns NULL on failure.\n\nPrototype\n\nstruct aws_event_stream_rpc_client_continuation_token * aws_event_stream_rpc_client_connection_new_stream( struct aws_event_stream_rpc_client_connection *connection, const struct aws_event_stream_rpc_client_stream_continuation_options *continuation_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_client_connection_release-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_client_connection_release","text":"aws_event_stream_rpc_client_connection_release(connection)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_event_stream_rpc_client_connection_release( const struct aws_event_stream_rpc_client_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_client_connection_send_protocol_message-NTuple{4, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_client_connection_send_protocol_message","text":"aws_event_stream_rpc_client_connection_send_protocol_message(connection, message_args, flush_fn, user_data)\n\nSends a message on the connection. These must be connection level messages (not application messages).\n\nflush_fn will be invoked when the message has been successfully writen to the wire or when it fails.\n\nreturns AWS_OP_SUCCESS if the message was successfully created and queued, and in that case flush_fn will always be invoked. Otherwise, flush_fn will not be invoked.\n\nPrototype\n\nint aws_event_stream_rpc_client_connection_send_protocol_message( struct aws_event_stream_rpc_client_connection *connection, const struct aws_event_stream_rpc_message_args *message_args, aws_event_stream_rpc_client_message_flush_fn *flush_fn, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_client_continuation_acquire-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_client_continuation_acquire","text":"aws_event_stream_rpc_client_continuation_acquire(continuation)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_event_stream_rpc_client_continuation_acquire( const struct aws_event_stream_rpc_client_continuation_token *continuation);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_client_continuation_activate-NTuple{5, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_client_continuation_activate","text":"aws_event_stream_rpc_client_continuation_activate(continuation, operation_name, message_args, flush_fn, user_data)\n\nActually sends the initial stream to the peer. Callbacks from aws_event_stream_rpc_client_connection_new_stream() will actually be invoked if this function returns AWS_OP_SUCCESS, otherwise, the stream has not been queued and no callbacks will be invoked.\n\noperation_name is the name to identify which logical rpc call you want to kick off with the peer. It must be non-empty. flush_fn will be invoked once the message has either been written to the wire or it fails.\n\nPrototype\n\nint aws_event_stream_rpc_client_continuation_activate( struct aws_event_stream_rpc_client_continuation_token *continuation, struct aws_byte_cursor operation_name, const struct aws_event_stream_rpc_message_args *message_args, aws_event_stream_rpc_client_message_flush_fn *flush_fn, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_client_continuation_get_user_data-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_client_continuation_get_user_data","text":"aws_event_stream_rpc_client_continuation_get_user_data(continuation)\n\nDocumentation not found.\n\nPrototype\n\nvoid *aws_event_stream_rpc_client_continuation_get_user_data( struct aws_event_stream_rpc_client_continuation_token *continuation);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_client_continuation_is_closed-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_client_continuation_is_closed","text":"aws_event_stream_rpc_client_continuation_is_closed(continuation)\n\nreturns true if the continuation has been closed.\n\nPrototype\n\nbool aws_event_stream_rpc_client_continuation_is_closed( const struct aws_event_stream_rpc_client_continuation_token *continuation);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_client_continuation_release-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_client_continuation_release","text":"aws_event_stream_rpc_client_continuation_release(continuation)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_event_stream_rpc_client_continuation_release( const struct aws_event_stream_rpc_client_continuation_token *continuation);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_client_continuation_send_message-NTuple{4, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_client_continuation_send_message","text":"aws_event_stream_rpc_client_continuation_send_message(continuation, message_args, flush_fn, user_data)\n\nSends a message on the continuation. aws_event_stream_rpc_client_continuation_activate() must be successfully invoked prior to calling this function.\n\nIf this function returns AWS_OP_SUCCESS, flush_fn will be invoked once the message has either been written to the wire or it fails.\n\nPrototype\n\nint aws_event_stream_rpc_client_continuation_send_message( struct aws_event_stream_rpc_client_continuation_token *continuation, const struct aws_event_stream_rpc_message_args *message_args, aws_event_stream_rpc_client_message_flush_fn *flush_fn, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_connection_acquire-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_connection_acquire","text":"aws_event_stream_rpc_server_connection_acquire(connection)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_event_stream_rpc_server_connection_acquire( struct aws_event_stream_rpc_server_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_connection_close-Tuple{Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_connection_close","text":"aws_event_stream_rpc_server_connection_close(connection, shutdown_error_code)\n\nCloses the connection (including all continuations on the connection), and releases the connection ref count. shutdown_error_code is the error code to use when shutting down the channel. Use AWS_ERROR_SUCCESS for non-error cases.\n\nPrototype\n\nvoid aws_event_stream_rpc_server_connection_close( struct aws_event_stream_rpc_server_connection *connection, int shutdown_error_code);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_connection_from_existing_channel-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_connection_from_existing_channel","text":"aws_event_stream_rpc_server_connection_from_existing_channel(server, channel, connection_options)\n\nBypasses server, and creates a connection on an already existing channel. No connection lifetime callbacks will be invoked on the returned connection. Returns NULL if an error occurs. If and only if, you use this API, the returned connection is already ref counted and you must call aws_event_stream_rpc_server_connection_release() even if you did not explictly call aws_event_stream_rpc_server_connection_acquire()\n\nPrototype\n\nstruct aws_event_stream_rpc_server_connection * aws_event_stream_rpc_server_connection_from_existing_channel( struct aws_event_stream_rpc_server_listener *server, struct aws_channel *channel, const struct aws_event_stream_rpc_connection_options *connection_options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_connection_get_user_data-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_connection_get_user_data","text":"aws_event_stream_rpc_server_connection_get_user_data(connection)\n\nDocumentation not found.\n\nPrototype\n\nvoid *aws_event_stream_rpc_server_connection_get_user_data( struct aws_event_stream_rpc_server_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_connection_is_open-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_connection_is_open","text":"aws_event_stream_rpc_server_connection_is_open(connection)\n\nreturns true if the connection is open. False otherwise.\n\nPrototype\n\nbool aws_event_stream_rpc_server_connection_is_open( struct aws_event_stream_rpc_server_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_connection_release-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_connection_release","text":"aws_event_stream_rpc_server_connection_release(connection)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_event_stream_rpc_server_connection_release( struct aws_event_stream_rpc_server_connection *connection);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_connection_send_protocol_message-NTuple{4, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_connection_send_protocol_message","text":"aws_event_stream_rpc_server_connection_send_protocol_message(connection, message_args, flush_fn, user_data)\n\nSends a protocol message on the connection (not application data). If the message is valid and successfully written to the channel, flush_fn will be invoked.\n\nPrototype\n\nint aws_event_stream_rpc_server_connection_send_protocol_message( struct aws_event_stream_rpc_server_connection *connection, const struct aws_event_stream_rpc_message_args *message_args, aws_event_stream_rpc_server_message_flush_fn *flush_fn, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_continuation_acquire-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_continuation_acquire","text":"aws_event_stream_rpc_server_continuation_acquire(continuation)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_event_stream_rpc_server_continuation_acquire( struct aws_event_stream_rpc_server_continuation_token *continuation);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_continuation_is_closed-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_continuation_is_closed","text":"aws_event_stream_rpc_server_continuation_is_closed(continuation)\n\nreturns true if the continuation is still in an open state.\n\nPrototype\n\nbool aws_event_stream_rpc_server_continuation_is_closed( struct aws_event_stream_rpc_server_continuation_token *continuation);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_continuation_release-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_continuation_release","text":"aws_event_stream_rpc_server_continuation_release(continuation)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_event_stream_rpc_server_continuation_release( struct aws_event_stream_rpc_server_continuation_token *continuation);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_continuation_send_message-NTuple{4, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_continuation_send_message","text":"aws_event_stream_rpc_server_continuation_send_message(continuation, message_args, flush_fn, user_data)\n\nSends an application message on the continuation. If the message is valid and successfully written to the channel, flush_fn will be invoked.\n\nPrototype\n\nint aws_event_stream_rpc_server_continuation_send_message( struct aws_event_stream_rpc_server_continuation_token *continuation, const struct aws_event_stream_rpc_message_args *message_args, aws_event_stream_rpc_server_message_flush_fn *flush_fn, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_listener_acquire-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_listener_acquire","text":"aws_event_stream_rpc_server_listener_acquire(listener)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_event_stream_rpc_server_listener_acquire( struct aws_event_stream_rpc_server_listener *listener);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_listener_get_bound_port-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_listener_get_bound_port","text":"aws_event_stream_rpc_server_listener_get_bound_port(listener)\n\nGet the local port which the listener's socket is bound to.\n\nPrototype\n\nuint32_t aws_event_stream_rpc_server_listener_get_bound_port( const struct aws_event_stream_rpc_server_listener *listener);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_listener_release-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_listener_release","text":"aws_event_stream_rpc_server_listener_release(listener)\n\nDocumentation not found.\n\nPrototype\n\nvoid aws_event_stream_rpc_server_listener_release( struct aws_event_stream_rpc_server_listener *listener);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_rpc_server_new_listener-Tuple{Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_rpc_server_new_listener","text":"aws_event_stream_rpc_server_new_listener(allocator, options)\n\nCreates a listener with a ref count of 1. You are responsible for calling aws_event_stream_rpc_server_listener_release() when you're finished with the listener. Returns NULL if an error occurs.\n\nPrototype\n\nstruct aws_event_stream_rpc_server_listener *aws_event_stream_rpc_server_new_listener( struct aws_allocator *allocator, struct aws_event_stream_rpc_server_listener_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_streaming_decoder_clean_up-Tuple{Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_streaming_decoder_clean_up","text":"aws_event_stream_streaming_decoder_clean_up(decoder)\n\nCurrently, no memory is allocated inside aws_aws_event_stream_streaming_decoder, but for future API compatibility, you should call this when finished with it.\n\nPrototype\n\nvoid aws_event_stream_streaming_decoder_clean_up( struct aws_event_stream_streaming_decoder *decoder);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_streaming_decoder_init-NTuple{7, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_streaming_decoder_init","text":"aws_event_stream_streaming_decoder_init(decoder, alloc, on_payload_segment, on_prelude, on_header, on_error, user_data)\n\nDeprecated. Use aws_event_stream_streaming_decoder_init_from_options instead. Initialize a streaming decoder for messages with callbacks for usage and an optional user context pointer.\n\nPrototype\n\nvoid aws_event_stream_streaming_decoder_init( struct aws_event_stream_streaming_decoder *decoder, struct aws_allocator *alloc, aws_event_stream_process_on_payload_segment_fn *on_payload_segment, aws_event_stream_prelude_received_fn *on_prelude, aws_event_stream_header_received_fn *on_header, aws_event_stream_on_error_fn *on_error, void *user_data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_streaming_decoder_init_from_options-Tuple{Any, Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_streaming_decoder_init_from_options","text":"aws_event_stream_streaming_decoder_init_from_options(decoder, allocator, options)\n\nInitialize a streaming decoder for messages with callbacks for usage and an optional user context pointer.\n\nPrototype\n\nvoid aws_event_stream_streaming_decoder_init_from_options( struct aws_event_stream_streaming_decoder *decoder, struct aws_allocator *allocator, const struct aws_event_stream_streaming_decoder_options *options);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_streaming_decoder_pump-Tuple{Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_streaming_decoder_pump","text":"aws_event_stream_streaming_decoder_pump(decoder, data)\n\nThe main driver of the decoder. Pass data that should be decoded with its length. A likely use-case here is in response to a read event from an io-device\n\nPrototype\n\nint aws_event_stream_streaming_decoder_pump( struct aws_event_stream_streaming_decoder *decoder, const struct aws_byte_buf *data);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_write_headers_to_buffer-Tuple{Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_write_headers_to_buffer","text":"aws_event_stream_write_headers_to_buffer(headers, buffer)\n\nDeprecated in favor of 'aws_event_stream_write_headers_to_buffer_safe' as this API is unsafe.\n\nWrites headers to buffer and returns the length of bytes written to buffer. Assumes buffer is large enough to store the headers.\n\nPrototype\n\nsize_t aws_event_stream_write_headers_to_buffer(const struct aws_array_list *headers, uint8_t *buffer);\n\n\n\n\n\n","category":"method"},{"location":"#LibAwsEventStream.aws_event_stream_write_headers_to_buffer_safe-Tuple{Any, Any}","page":"Home","title":"LibAwsEventStream.aws_event_stream_write_headers_to_buffer_safe","text":"aws_event_stream_write_headers_to_buffer_safe(headers, buf)\n\nWrites headers to buf assuming buf is large enough to hold the data. Prefer this function over the unsafe variant 'aws_event_stream_write_headers_to_buffer'.\n\nReturns AWS_OP_SUCCESS if the headers were successfully and completely written and AWS_OP_ERR otherwise.\n\nPrototype\n\nint aws_event_stream_write_headers_to_buffer_safe( const struct aws_array_list *headers, struct aws_byte_buf *buf);\n\n\n\n\n\n","category":"method"}]
}
